TestCase subclass: #TweetsParsorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TweetsParser'!!TweetsParsorTest methodsFor: 'as yet unclassified' stamp: 'KedarPitke 11/22/2015 00:50'!testparseToJSON| x p|p := TweetsParsor new.x := p parseToJSON.self deny: (x size = 0).self assert: (x size = 9).x := p parseToJSON: 'tweets.json'.self deny: (x size = 0).self assert: (x size = 9).! !!TweetsParsorTest methodsFor: 'as yet unclassified' stamp: 'KedarPitke 11/22/2015 02:06'!testaddUserDetail| p tweet x userOBJ |p := TweetsParsor new.tweet := Tweet new.x := Dictionary new.                                     x add: #created_at->'Fri Aug 07 00:26:48 +0000 2015'; 	add: #favourites_count->111; 	add: #followers_count->222; 	add: #friends_count->333; 	add: #name->'Johnny Bravo'; 	add: #statuses_count->444; 	add: #location->'Moon'; 	add: #time_zone->'Mars';	add: #lang->'Elvish'; yourself.tweet user: x. userOBJ := p addUserDetail: tweet.self deny: (userOBJ = nil).self assert: (userOBJ created_at = 'Fri Aug 07 00:26:48 +0000 2015').self assert: (userOBJ favourites_count = 111).self assert: (userOBJ followers_count = 222).self assert: (userOBJ friends_count = 333).self assert: (userOBJ statuses_count = 444).self assert: (userOBJ location = 'Moon').self assert: (userOBJ name = 'Johnny Bravo').self assert: (userOBJ time_zone = 'Mars').self assert: (userOBJ lang = 'Elvish').     ! !!TweetsParsorTest methodsFor: 'as yet unclassified' stamp: 'KedarPitke 11/22/2015 03:31'!testaddEntityDetail| p x tweet mdict harray marray   entityOBJ hdict1 hdict2|p := TweetsParsor new.tweet := Tweet new.mdict := Dictionary new.mdict add:(#type->'Video111'); add:(#url->'THIS IS URL').hdict1 := Dictionary new.hdict1 add:(#text->'Tag111').hdict2 := Dictionary new.hdict2 add:(#text->'Tag222').harray :=OrderedCollection new.harray add:hdict1;add:hdict2 .marray :=OrderedCollection new.marray add: mdict.                                   x := Dictionary new.                                     x add: #hashtags->harray; 	add: #media->marray; yourself.tweet entities: x. entityOBJ := p addEntityDetail: tweet.self deny: (entityOBJ = nil).self deny: (entityOBJ hashtags = nil).self deny: (entityOBJ media = nil).self assert: (entityOBJ media url = 'THIS IS URL').self assert: (entityOBJ media type = 'Video111').! !!TweetsParsorTest methodsFor: 'as yet unclassified' stamp: 'KedarPitke 11/22/2015 01:49'!setUp    | fileName p   |fileName := '.\Resources\tweets_iphone.json'.p := TweetsParsor new.! !Object subclass: #TweetsParsor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TweetsParser'!!TweetsParsor methodsFor: 'as yet unclassified' stamp: 'KedarPitke 11/22/2015 00:30'!parseToJSON|arrAgileTweet|arrAgileTweet := 'tweets.json' asFileReference readStreamDo: [ :in | (NeoJSONReader on: in readStream)  mapInstVarsFor: Tweet;  for: #ArrayOfAgileTweets customDo: [ :mapping | mapping   listOfElementSchema: Tweet ];   nextAs: #ArrayOfAgileTweets.].arrAgileTweet:= arrAgileTweet select: [ :tweet |  tweet user ~= nil ].arrAgileTweet do: [ :currTweet |		currTweet user: (self addUserDetail: currTweet).		currTweet entity: (self addEntityDetail: currTweet).		].	^arrAgileTweet 	! !!TweetsParsor methodsFor: 'as yet unclassified' stamp: 'KedarPitke 10/30/2015 02:17'!addEntityDetail:tweet 	"parse tweet dicitonary, get hashtag list, get media data, consruct Entity object"	"returns an entity object associated with a tweet"	| entityDict currEntity hashtagList  currHashtag tagList mediaList currMedia |		tagList := OrderedCollection new.	entityDict := tweet entity.	currEntity := Entity new.	hashtagList := entityDict at: 'hashtags'.	hashtagList do: [:tagDict | 		 currHashtag := Hashtag new.		currHashtag text: (tagDict at:'text').		tagList add: currHashtag.		].	currEntity hashtags:tagList.		(entityDict includesKey: #media) ifTrue:[	mediaList := entityDict at: 'media'.	mediaList do: [:mediaDict | 		 currMedia := Media new.		currMedia url: (mediaDict at:'url').		currMedia type: (mediaDict at:'type').		currEntity media: currMedia		].	].	^currEntity	 	! !!TweetsParsor methodsFor: 'as yet unclassified' stamp: 'snehalshendware 11/12/2015 10:47'!parseToJSON: jsonFile |arrAgileTweet|arrAgileTweet := jsonFile asFileReference readStreamDo: [ :in | (NeoJSONReader on: in readStream)  mapInstVarsFor: Tweet;  for: #ArrayOfAgileTweets customDo: [ :mapping | mapping   listOfElementSchema: Tweet ];   nextAs: #ArrayOfAgileTweets.].arrAgileTweet:= arrAgileTweet select: [ :tweet |  tweet user ~= nil ].arrAgileTweet do: [ :currTweet |		currTweet user: (self addUserDetail: currTweet).		currTweet entity: (self addEntityDetail: currTweet).		].	^arrAgileTweet 	! !!TweetsParsor methodsFor: 'as yet unclassified' stamp: 'KedarPitke 10/29/2015 21:52'!addUserDetail:tweet	"parse tweet dictionary, create user object, add user object to tweet object"	| userDict currUser |	userDict := tweet user.	currUser := User new.	currUser name:(userDict at: 'name').	currUser time_zone:(userDict at:'time_zone').	currUser location:(userDict at:'location').	currUser lang:(userDict at:'lang').	currUser created_at:(userDict at:'created_at').	currUser followers_count:(userDict at:'followers_count').	currUser favourites_count:(userDict at:'favourites_count').	currUser statuses_count:(userDict at:'statuses_count').	currUser friends_count:(userDict at:'friends_count').	^currUser ! !