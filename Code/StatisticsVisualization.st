Object subclass: #TotalTweets	instanceVariableNames: 'Viz'	classVariableNames: ''	poolDictionaries: ''	category: 'StatisticsVisualization'!!TotalTweets methodsFor: 'as yet unclassified' stamp: 'TanmayPatil 10/15/2015 02:55'!allTweets	^ allTweets! !!TotalTweets methodsFor: 'as yet unclassified' stamp: 'MeenalKulkarni 11/22/2015 16:40'!initDayOfWeekData	| dataSet d1 d2 d3 d4 d5 d6 d7 |	dataSet := OrderedCollection new.	d1 := OrderedCollection new.	d1 add: 'Mon'.	d1 add: 0.	d1 add: String new.	d1 add: 0.	dataSet add: d1.	d2 := OrderedCollection new.		d2 add: 'Tue'.	d2 add: 0.	d2 add: String new.	d2 add: 0.	dataSet add: d2.	d3 := OrderedCollection new.		d3 add: 'Wed'.	d3 add: 0.	d3 add: String new.	d3 add: 0.	dataSet add: d3.	d4 := OrderedCollection new.		d4 add: 'Thu'.	d4 add: 0.	d4 add: String new.	d4 add: 0.	dataSet add: d4.	d5 := OrderedCollection new.		d5 add: 'Fri'.	d5 add: 0.	d5 add: String new.	d5 add: 0.	dataSet add: d5.	d6 := OrderedCollection new.		d6 add: 'Sat'.	d6 add: 0.	d6 add: String new.	d6 add: 0.	dataSet add: d6.	d7 := OrderedCollection new.		d7 add: 'Sun'.	d7 add: 0.	d7 add: String new.	d7 add: 0.	dataSet add: d7.	^ dataSet! !!TotalTweets methodsFor: 'as yet unclassified' stamp: 'MeenalKulkarni 11/15/2015 20:20'!showBySensitivity|tweets possibly_true_count falseSensitiveTweets trueSensitiveTweets tp trueCnt falseCnt b ds  n|tweets := OrderedCollection new.possibly_true_count := OrderedCollection new.tp := TweetsParsor new.tweets := tp parseToJSON. possibly_true_count := tweets collect: [:each | each possibly_sensitive].possibly_true_count at: 1.trueCnt:= 0.falseCnt:= 0.n:= possibly_true_count size.1 to: n do:[:index|(possibly_true_count at: index) ifTrue:[trueCnt:=trueCnt + 1] ifFalse:[falseCnt := falseCnt + 1]].b := RTGrapher new.ds := RTStackedDataSet new.falseSensitiveTweets := OrderedCollection new.trueSensitiveTweets := OrderedCollection new.tweets do: [ :tweet |tweet possibly_sensitive = false ifTrue:[falseSensitiveTweets add: tweet text]	ifFalse:[trueSensitiveTweets add: tweet text]	].	ds points: { { 'True'. trueCnt . trueSensitiveTweets} . 		{'False' . falseCnt . falseSensitiveTweets} }.ds y: #second.ds barShape width: 40.ds histogramWithBarTitle: #first rotation: -45.b add: ds.b axisX noLabel; noTick.b build.^ b view.! !!TotalTweets methodsFor: 'as yet unclassified' stamp: 'MeenalKulkarni 11/22/2015 16:43'!showTemporalDivisonComposed| composer v b tweets tp dataSet day row count ds k month  textCollection  str cnt n a |composer := RTComposer new.	v := composer view.		"========"	b := RTGrapher new. 		b view: v.	tweets := OrderedCollection new.	tp := TweetsParsor new.	tweets := tp parseToJSON.	dataSet := self initDayOfWeekData.		textCollection := OrderedCollection new.		tweets do: [ :tweet |		tweet created_at = -1 ifFalse: [ 			day := (tweet created_at substrings: ' ') at: 1.			row := (dataSet select: [ :i |				(i at: 1) = day			]) at: 1.			count := row at: 2.			row at: 2 put: (count + 1).						str := row at: 3.			cnt := row at: 4.			cnt := count + 1.			str := str , cnt asString , ')', tweet text , String cr.			row at: 3 put: str. 			row at: 4 put: cnt.			 			].		 	].			ds := RTStackedDataSet new.	ds points: dataSet.	ds y: #second.	ds interaction highlightColored: Color red.	ds interaction popup		background: Color lightBlue		group: [ :group :element |		| s  |		n := element model at: 3.		s := RTLabel new text: n.		a := OrderedCollection new.		a add: 1.		group addAll: (s elementsOn: a asArray).		RTGridLayout on: group ].	ds barShape width: 30;color: Color blue.	ds histogramWithBarTitle: #first rotation: -45.	b add: ds.	b axisX noLabel; noTick.	b build.	composer group: #daywise.			"========"	k := RTGrapher new..		k view: v.	tweets := OrderedCollection new.	tp := TweetsParsor new.	tweets := tp parseToJSON.	dataSet := self initMonthlyData.			tweets do: [ :tweet |		tweet created_at = -1 ifFalse: [ 			month := (tweet created_at substrings: ' ') at: 2.			row := (dataSet select: [ :i |				(i at: 1) = month			]) at: 1.			count := row at: 2.			row at: 2 put: (count + 1).			str := row at: 3.			count := row at: 4.			count := count + 1.			str := str , count asString , ')', tweet text , String cr.			row at: 3 put: str. 			row at: 4 put: count. 		].	].			ds := RTStackedDataSet new.	ds points: dataSet.	ds y: #second.	ds interaction highlightColored: Color red.	ds interaction popup		background: Color lightBlue		group: [ :group :element |		| s  |		n := element model at: 3.		s := RTLabel new text: n.		a := OrderedCollection new.		a add: 1.		group addAll: (s elementsOn: a asArray).		RTGridLayout on: group ].	ds barShape width: 30;color: Color blue.	ds histogramWithBarTitle: #first rotation: -45.	k add: ds.	k axisX noLabel; noTick.	k build.	composer group: #monthwise.	composer move: #monthwise above: #daywise.		composer nameGroup: #monthwise as: 'Month-wise distribution of tweets'.	composer nameGroup: #daywise as: 'Day-wise distribution of tweets'. ^v! !!TotalTweets methodsFor: 'as yet unclassified' stamp: 'MeenalKulkarni 11/22/2015 16:41'!showByDayOfWeek| b ds tweets tp   dataSet   row count  day  n a str cnt |	tweets := OrderedCollection new.	tp := TweetsParsor new.	tweets := tp parseToJSON.	dataSet := self initDayOfWeekData.				tweets do: [ :tweet |		tweet created_at = -1 ifFalse: [ 			day := (tweet created_at substrings: ' ') at: 1.			row := (dataSet select: [ :i |				(i at: 1) = day			]) at: 1.			count := row at: 2.			row at: 2 put: (count + 1).						str := row at: 3.			cnt := row at: 4.			cnt := count + 1.			str := str , cnt asString , ')', tweet text , String cr.			row at: 3 put: str. 			row at: 4 put: cnt.			 			].		 	].		b := RTGrapher new.	ds := RTStackedDataSet new.	ds points: dataSet.	ds y: #second.	ds interaction highlightColored: Color red.	ds interaction popup		background: Color lightBlue		group: [ :group :element |		| s  |		n := element model at: 3.		s := RTLabel new text: n.		a := OrderedCollection new.		a add: 1.		group addAll: (s elementsOn: a asArray).		RTGridLayout on: group ].	ds barShape width: 30;color: Color blue.	ds histogramWithBarTitle: #first rotation: -45.	b add: ds.	b axisX noLabel; noTick.	b build.	^ b view! !!TotalTweets methodsFor: 'as yet unclassified' stamp: 'KedarPitke 10/16/2015 20:25'!initialize	super initialize.	"TODO - Write CSV / JSON parser here."	Viz = true	! !!TotalTweets methodsFor: 'as yet unclassified' stamp: 'MeenalKulkarni 11/22/2015 17:26'!showTweetVizNextGen	"comment stating purpose of message"	| composer v  tweets  tp    dataSet day row count b ds month               k    directoryName analyzer sentimentsDict rtOSM tweets_brand1 tp1 name_of_brand1 tweets_brand2 tp2 name_of_brand2 sentiment title1 title2 str cnt n a brand1_text brand2_text |	composer := RTComposer new.	v := composer view.	v addMenu: 'Sentiment Global'		callback: [ 			v clean.			v signalUpdate.						directoryName:='analyzed_Time_zone_specific_tweets'.			analyzer:= RegionWiseSentimentAnalyzer new.			sentimentsDict:=analyzer getSentimentsDict:directoryName.			rtOSM:=RTOSMTweet new.			rtOSM plotSentimentOnOSM:sentimentsDict on:v.						v signalUpdate ].		v addMenu: 'Brand Comparision'		callback: [ 			v clean.			v signalUpdate.			v canvas camera scale: 1.			tweets_brand1 := OrderedCollection new.	tp1 := TweetsParsor new.	tweets_brand1 := tp1 parseToJSON: 'analyzed_tweets_#DonaldTrump.json'.	name_of_brand1 := 'Donald Trump'.		tweets_brand2 := OrderedCollection new.	tp2 := TweetsParsor new.	tweets_brand2 := tp2 parseToJSON: 'analyzed_tweets_#HillaryClinton.json'.	name_of_brand2 := 'Hillary Clinton'.		dataSet := Analysis new initComparisonData.		tweets_brand1 do: [ :tweet |		tweet sentiment = -1 ifFalse: [			sentiment := tweet sentiment.			row := (dataSet select: [ : id |				(id at: 1) = sentiment			]) at: 1.			count := row at: 2.			row at: 2 put: (count + 1).			brand1_text := row at: 4.			count := row at: 6.			brand1_text := brand1_text, (count+1) asString , ')', tweet text , String cr.			row at: 4 put: brand1_text. 			row at: 6 put: (count + 1).		].	].	tweets_brand2 do: [ :tweet |		tweet sentiment = -1 ifFalse: [			sentiment := tweet sentiment.			row := (dataSet select: [ :id |				(id at: 1) = sentiment			]) at: 1.			count := row at: 3.			row at: 3 put: (count + 1).			brand2_text := row at: 5.			count := row at: 7.			brand2_text := brand2_text, (count+1) asString , ')', tweet text , String cr.			row at: 5 put: brand2_text. 			row at: 7 put: (count + 1).		].	].	b := RTDoubleBarBuilder new.	b view: v.	b pointName: [ :row1 | row1 at: 1 ].	b points: dataSet.		title1 := 'GREY: ', name_of_brand1, ' (x 10)'.	title2 := 'RED: ', name_of_brand2, ' (x 10)'.	b bottomValue: [ : row2 | ((row2 at: 2) / 10) asInteger ]titled: title1.	b topValue: [ :row3 | ((row3 at: 3) / 10) asInteger] titled: title2.	b build.	composer group: #daywise.			composer setGeneralTitle: 'General Sentiment of Brands'.			v signalUpdate ].			v addMenu: 'Temporal'		callback: [ 			"========"			v clean.			v signalUpdate.			v canvas camera scale: 1.			b := RTGrapher new.			b view: v.			tweets := OrderedCollection new.			tp := TweetsParsor new.			tweets := tp parseToJSON.			dataSet := TotalTweets new initDayOfWeekData.						tweets				do: [ :tweet | 					tweet created_at = -1						ifFalse: [ 							day := (tweet created_at substrings: ' ') at: 1.							row := (dataSet select: [ :i1 | (i1 at: 1) = day ]) at: 1.							count := row at: 2.			row at: 2 put: (count + 1).						str := row at: 3.			cnt := row at: 4.			cnt := count + 1.			str := str , cnt asString , ')', tweet text , String cr.			row at: 3 put: str. 			row at: 4 put: cnt.] ].			ds := RTStackedDataSet new.			ds points: dataSet.			ds y: #second.						ds interaction highlightColored: Color red.			ds interaction popup				background: Color lightBlue				group: [ :group :element |				| s  |				n := element model at: 3.				s := RTLabel new text: n.				a := OrderedCollection new.				a add: 1.		group addAll: (s elementsOn: a asArray).		RTGridLayout on: group ].			ds barShape width: 15.			ds histogramWithBarTitle: #first rotation: -45.			b add: ds.			b axisX				noLabel;				noTick.			b build.			composer group: #daywise.	"========"			k := RTGrapher new.			k view: v.			tweets := OrderedCollection new.			tp := TweetsParsor new.			tweets := tp parseToJSON.			dataSet := TotalTweets new initMonthlyData.						tweets				do: [ :tweet | 					tweet created_at = -1						ifFalse: [ 							month := (tweet created_at substrings: ' ') at: 2.							row := (dataSet select: [ :i1 | (i1 at: 1) = month ]) at: 1.							count := row at: 2.			row at: 2 put: (count + 1).			str := row at: 3.			count := row at: 4.			count := count + 1.			str := str , count asString , ')', tweet text , String cr.			row at: 3 put: str. 			row at: 4 put: count.].			].			ds := RTStackedDataSet new.			ds points: dataSet.			ds y: #second.			ds interaction highlightColored: Color red.			ds interaction popup				background: Color lightBlue				group: [ :group :element |				| s  |				n := element model at: 3.				s := RTLabel new text: n.				a := OrderedCollection new.				a add: 1.		group addAll: (s elementsOn: a asArray).		RTGridLayout on: group ].			ds barShape width: 15.			ds histogramWithBarTitle: #first rotation: -45.			k add: ds.			k axisX				noLabel;				noTick.			k build.			composer group: #monthwise.			composer move: #monthwise above: #daywise.			composer nameGroup: #monthwise as: 'Month-wise distribution of tweets'.			composer nameGroup: #daywise as: 'Day-wise distribution of tweets'.			v signalUpdate ].	^ v! !!TotalTweets methodsFor: 'as yet unclassified' stamp: 'KedarPitke 11/21/2015 22:06'!showByUserPopularity| tweets followers_count_list v es tp  |tweets := OrderedCollection new.followers_count_list := OrderedCollection new.tp := TweetsParsor new.tweets := tp parseToJSON: 'tweets_iphone.json'. followers_count_list := tweets collect: [:each | each user followers_count ].followers_count_list  := followers_count_list asSortedCollection: [:f1 :f2 | f1 > f2].followers_count_list  :=followers_count_list first: 10.v := RTView new.	es := (RTBox new size: 15; color: Color blue) elementsOn: followers_count_list.	v addAll: es.	es @ RTPopup.	RTMetricNormalizer new		elements: es;		alphaColor: 0.8;		normalizeHeight: #yourself min: 50 max: 200.	RTHorizontalLineLayout new alignBottom; on: es.	es @ RTLabelled.	^v view! !!TotalTweets methodsFor: 'as yet unclassified' stamp: 'MeenalKulkarni 11/22/2015 16:42'!showByMonth| b ds tweets tp  month dataSet  row count   str n a |	tweets := OrderedCollection new.	tp := TweetsParsor new.	tweets := tp parseToJSON.	dataSet := self initMonthlyData.		tweets do: [ :tweet |		tweet created_at = -1 ifFalse: [ 			month := (tweet created_at substrings: ' ') at: 2.			row := (dataSet select: [ :i |				(i at: 1) = month			]) at: 1.			count := row at: 2.			row at: 2 put: (count + 1).			str := row at: 3.			count := row at: 4.			count := count + 1.			str := str , count asString , ')', tweet text , String cr.			row at: 3 put: str. 			row at: 4 put: count.					].		].		b := RTGrapher new.	ds := RTStackedDataSet new.	ds points: dataSet.	ds y: #second.	ds interaction popup		background: Color lightBlue		group: [ :group :element |		| s  |		n := element model at: 3.		s := RTLabel new text: n.		a := OrderedCollection new.		a add: 1.		group addAll: (s elementsOn: a asArray).		RTGridLayout on: group ].		ds barShape width: 30;color: Color blue.	ds histogramWithBarTitle: #first rotation: -45.	b add: ds.	b axisX noLabel; noTick.	b build.	^ b view ! !!TotalTweets methodsFor: 'as yet unclassified' stamp: 'MeenalKulkarni 11/22/2015 17:27'!showTweetVizRelational	"comment stating purpose of message"	| composer v  tweets  tp    dataSet  row count b ds   entities htArrays htTextArrays connected_hashtag htDict y view v1 mymap reader locationDict locationToCountMapping keys size i locString tweetParser tweetArray curtweet user timezone   sentiment s AllHashtag AllHashtagUC str n a1 |	composer := RTComposer new.	v := composer view.	v addMenu: 'HashTag Relation'		callback: [ 			v clean.			v signalUpdate.			v canvas camera scale: 1.			tweets := OrderedCollection new.			entities := OrderedCollection new.			htArrays := OrderedCollection new.			htTextArrays := OrderedCollection new.			AllHashtag := OrderedCollection new.			AllHashtagUC := OrderedCollection new.			AllHashtag := OrderedCollection new.			connected_hashtag := OrderedCollection new.			htDict := Dictionary new.			tp := TweetsParsor new.			tweets := tp parseToJSON: 'tweets.json'.			entities := tweets collect: [ :tweet | tweet entities ].			htArrays := entities collect: [ :entity | entity hashtags ].			htTextArrays := htArrays collect: [ :htag | htag collect: [ :x | x text ] ].			htTextArrays do: [ :htag |					htag = -1						ifFalse: [ htag do: [ :a | AllHashtag add: a ] ] ].			AllHashtagUC := AllHashtag collect: [ :x | y := x asUppercase ].			AllHashtagUC				do: [ :x | 					(htDict includesKey: x asUppercase)						ifFalse: [ 							htDict								add: x asUppercase -> 1;								yourself ]						ifTrue: [ 							count := htDict at: x.							htDict								add: x asUppercase -> (count + 1);								yourself ] ].			AllHashtag := (htDict associations sort: [ :assoc1 :assoc2 | assoc1 value > assoc2 value ])				collect: [ :assoc | assoc key ].			htTextArrays				do: [ :hTagList | 					hTagList isEmpty						ifFalse: [ 							hTagList								do: [ :parentTag | 									hTagList										do: [ :childTag | 											connected_hashtag												add: parentTag asUppercase -> childTag asUppercase;												yourself ] ] ] ].			v1 := ROView new.			view := ROMondrianViewBuilder view: v1.			view title: 'Closely related Hashtags'.			view shape circle				size: 30;				color: (Color blue alpha: 0.5).			view interaction				on: ROMouseEnter				do: [ :evt | 					view raw elementsAsEdge						do: [ :edg | 							edg from == evt element								ifTrue: [ ROBlink on: edg ] ] ].			view nodes: AllHashtag.			view shape line.			view edges: connected_hashtag from: #key to: #value.			view circleLayout.			ROEaselMorphic new populateMenuOn: view.			view open.			v signalUpdate ].	v addMenu: 'GeoSpatial'		callback: [ 			v clean.			v signalUpdate.			mymap := RTOSMTweet new.			reader := CSVReader new.			locationDict := reader parseCSV.			locationToCountMapping := Dictionary new.			keys := locationDict keys.			size := keys size.			i := 1.			[ i <= size ]				whileTrue: [ 					locString := keys at: i.					locationToCountMapping at: locString put: 0.					i := i + 1 ].			locationToCountMapping.			tweetParser := TweetsParsor new.			tweetArray := tweetParser parseToJSON:'tweets_iphone.json'.			size := tweetArray size.			i := 1.			[ i <= size ]				whileTrue: [ 					curtweet := tweetArray at: i.					user := curtweet user.					timezone := nil.					timezone := user time_zone.					timezone = nil						ifFalse: [ 							count := nil.							count := locationToCountMapping at: timezone ifPresent: [ locationToCountMapping at: timezone ].							count = nil								ifFalse: [ 									count := count + 1.									locationToCountMapping at: timezone put: count ] ].					i := i + 1 ].			locationToCountMapping.			mymap locationCountMapping: locationToCountMapping.			mymap plotOnOpenStreetMap: locationDict on: v.			v signalUpdate ].		v addMenu: 'Tweet Sentiment'		callback: [ 			v clean.			v signalUpdate.			v canvas camera scale: 1.			tweets := OrderedCollection new.			tp := TweetsParsor new.			s := Analysis new.			tweets := tp parseToJSON:'analyzed_tweets_#HillaryClinton.json'.		dataSet := s initSentimentData.		tweets do: [ :tweet |		tweet sentiment = -1 ifFalse: [			sentiment := tweet sentiment.				row := (dataSet select: [ :i1 |				(i1 at: 1) = sentiment			]) at: 1.			count := row at: 2.			row at: 2 put: (count + 1).			str := row at: 3.			count := row at: 4.			count := count + 1.			str := str , count asString , ')', tweet text , String cr.			row at: 3 put: str. 			row at: 4 put: count.		].	].		b := RTGrapher new.	b view: v.	ds := RTStackedDataSet new.	ds points: dataSet.	ds y: #second.	ds interaction highlightColored: Color red.	ds interaction popup		background: Color lightBlue		group: [ :group :element |		|  s1  |		n := element model at: 3.		s1 := RTLabel new text: n.		a1 := OrderedCollection new.		a1 add: 1.		group addAll: (s1 elementsOn: a1 asArray).		RTGridLayout on: group ].	ds barShape width: 40; color: Color blue.	ds histogramWithBarTitle: #first rotation: -45 color: Color black.	b add: ds.	b axisX noLabel; noTick.	b build.	composer group: #daywise.			composer setGeneralTitle: 'Sentiment Analysis of Tweets'.			v signalUpdate].	^ v! !!TotalTweets methodsFor: 'as yet unclassified' stamp: 'MeenalKulkarni 11/22/2015 17:28'!showTweetVizStats	"comment stating purpose of message"	| composer v previousElements tweets followers_count_list tp shape es retweet_count_list dataSet day row count b ds str cnt n a |	composer := RTComposer new.	v := composer view.		v addMenu: 'User Popularity'		callback: [ 			v clean.			v signalUpdate.			v canvas camera scale: 1.			previousElements := v elements.			tweets := OrderedCollection new.			followers_count_list := OrderedCollection new.			tp := TweetsParsor new.			tweets := tp parseToJSON: 'tweets_iphone.json'.			followers_count_list := tweets collect: [ :each | each user followers_count ].			followers_count_list := followers_count_list asSortedCollection: [ :f1 :f2 | f1 > f2 ].			followers_count_list := followers_count_list first: 10.			shape := RTCompositeShape new.			shape add: (RTBox new color: Color blue).			shape add: (RTRotatedLabel new angleInDegree: -90).			es := shape elementsOn: followers_count_list.			v addAll: es.			es @ RTPopup.			composer group: #daywise.			composer setGeneralTitle: 'User Popularity by Follower Count'.	"composer nameGroup: #daywise as: 'User Popularity by Follower Count'."			RTMetricNormalizer new				elements: es;				alphaColor: 0.8;				normalizeHeight: #yourself min: 50 max: 200.			RTHorizontalLineLayout new				alignBottom;				on: es.			v signalUpdate	"TRConstraint move: newElements below: previousElements. " ].		v addMenu: 'RetweetCount'		callback: [ 			v clean.			v signalUpdate.			v canvas camera scale: 1.			previousElements := v elements.			tweets := OrderedCollection new.			retweet_count_list := OrderedCollection new.			tp := TweetsParsor new.			tweets := tp parseToJSON: 'tweets.json'.			retweet_count_list := tweets collect: [ :each | each retweet_count ].			shape := RTCompositeShape new.			shape				add:					(RTBox new						color: Color blue;						size: 30).			es := shape elementsOn: retweet_count_list.			v addAll: es.			es @ RTPopup.			RTMetricNormalizer new				elements: es;				alphaColor: 0.8;				normalizeHeight: #yourself min: 0 max: 80.			RTHorizontalLineLayout new				alignBottom;				on: es.			composer group: #daywise.			composer setGeneralTitle: 'Popularity by Retweet Distribution'.			es @ RTLabelled.			v signalUpdate ].	v addMenu: 'DaysOfWeek'		callback: [ 			v clean.			v signalUpdate.			v canvas camera scale: 1.			tweets := OrderedCollection new.			tp := TweetsParsor new.			tweets := tp parseToJSON: 'tweets_iphone.json'.			dataSet := TotalTweets new initDayOfWeekData.			tweets do: [ :tweet |		tweet created_at = -1 ifFalse: [ 			day := (tweet created_at substrings: ' ') at: 1.			row := (dataSet select: [ :i |				(i at: 1) = day			]) at: 1.			count := row at: 2.			row at: 2 put: (count + 1).			str := row at: 3.			cnt := row at: 4.			cnt := count + 1.			str := str , cnt asString , ')', tweet text , String cr.			row at: 3 put: str. 			row at: 4 put: cnt.	 ]. ].			b := RTGrapher new.			b view: v.			ds := RTStackedDataSet new.			ds points: dataSet.			ds y: #second.			ds interaction highlightColored: Color red.			ds interaction popup				background: Color lightBlue				group: [ :group :element |				| s  |				n := element model at: 3.				s := RTLabel new text: n.				a := OrderedCollection new.				a add: 1.		group addAll: (s elementsOn: a asArray).		RTGridLayout on: group ].			ds barShape				width: 30;				color: Color blue.			ds histogramWithBarTitle: #first rotation: -45.			b add: ds.			b axisX				noLabel;				noTick.			b build.			composer group: #daywise.			composer setGeneralTitle: 'Day-wise Tweets Distribution'.			v signalUpdate ].	^ v! !!TotalTweets methodsFor: 'as yet unclassified' stamp: 'KedarPitke 11/21/2015 22:06'!showByRetweetCount| tweets retweet_count_list v es tp|tweets := OrderedCollection new.retweet_count_list := OrderedCollection new.tp := TweetsParsor new.tweets := tp parseToJSON. retweet_count_list := tweets collect: [:each | each retweet_count].retweet_count_list  := retweet_count_list asSortedCollection: [:f1 :f2 | f1 > f2].retweet_count_list  :=retweet_count_list first: 5.v := RTView new.	es := (RTBox new size: 15; color: Color blue) elementsOn: retweet_count_list.	v addAll: es.	es @ RTPopup.	RTMetricNormalizer new		elements: es;		alphaColor: 0.8;		normalizeHeight: #yourself min: 0 max: 80.	RTHorizontalLineLayout new alignBottom; on: es.	es @ RTLabelled.	^v view! !!TotalTweets methodsFor: 'as yet unclassified' stamp: 'MeenalKulkarni 11/22/2015 16:41'!initMonthlyData	| dataSet d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12|	dataSet := OrderedCollection new.	d1 := OrderedCollection new.		d1 add: 'Jan'.	d1 add: 0.	d1 add: String new.	d1 add: 0.	dataSet add: d1.	d2 := OrderedCollection new.		d2 add: 'Feb'.	d2 add: 0.	d2 add: String new.	d2 add: 0.	dataSet add: d2.	d3 := OrderedCollection new.		d3 add: 'Mar'.	d3 add: 0.	d3 add: String new.	d3 add: 0.	dataSet add: d3.	d4 := OrderedCollection new.		d4 add: 'Apr'.	d4 add: 0.	d4 add: String new.	d4 add: 0.	dataSet add: d4.	d5 := OrderedCollection new.		d5 add: 'May'.	d5 add: 0.	d5 add: String new.	d5 add:0.	dataSet add: d5.	d6 := OrderedCollection new.		d6 add: 'Jun'.	d6 add: 0.	d6 add: String new.	d6 add: 0.	dataSet add: d6.	d7 := OrderedCollection new.		d7 add: 'Jul'.	d7 add: 0.	d7 add: String new.	d7 add: 0.	dataSet add: d7.	d8 := OrderedCollection new.		d8 add: 'Aug'.	d8 add: 0.	d8 add: String new.	d8 add: 0.	dataSet add: d8.	d9 := OrderedCollection new.		d9 add: 'Sep'.	d9 add: 0.	d9 add: String new.	d9 add: 0.	dataSet add: d9.	d10 := OrderedCollection new.		d10 add: 'Oct'.	d10 add: 0.	d10 add: String new.	d10 add: 0.	dataSet add: d10.	d11 := OrderedCollection new.		d11 add: 'Nov'.	d11 add: 0.	d11 add: String new.	d11 add: 0.	dataSet add: d11.	d12 := OrderedCollection new.		d12 add: 'Dec'.	d12 add: 0.	d12 add: String new.	d12 add:0.	dataSet add: d12.	^ dataSet! !!TotalTweets methodsFor: 'as yet unclassified' stamp: 'KedarPitke 11/15/2015 17:59'!showByHashTag| tp tweets entities htArrays htTextArrays AllHashtag AllHashtagUC htDict connected_hashtag count View view y|	tweets := OrderedCollection new.	entities := OrderedCollection new.	htArrays := OrderedCollection new.	htTextArrays := OrderedCollection new.	AllHashtag := OrderedCollection new.	AllHashtagUC := OrderedCollection new.	AllHashtag := OrderedCollection new.	connected_hashtag := OrderedCollection new.	htDict := Dictionary new.	tp := TweetsParsor new.	tweets := tp parseToJSON: 'tweets_iphone.json'.	entities := tweets collect: [:tweet | tweet entities ].	htArrays := entities collect: [:entity | entity hashtags]. 	htTextArrays := htArrays collect: [:htag | htag  collect: [:x | x text]].	htTextArrays do: [ :htag |		htag = -1 ifFalse: [			htag do: [:a |  AllHashtag add: a			].			].	].	AllHashtagUC := AllHashtag collect: [:x | y := (x asUppercase)].	AllHashtagUC do: [ :x |  (htDict includesKey: x asUppercase) 		ifFalse: [ htDict add: x asUppercase -> 1; yourself]		ifTrue: [ count := htDict at: x. 		       htDict add: x asUppercase -> (count + 1); yourself]	].	AllHashtag := (( htDict associations sort: [ :assoc1 :assoc2 | assoc1 value > assoc2 value ]) 	collect: [ :assoc | assoc key ]).		htTextArrays do: [ :hTagList |		(hTagList isEmpty) ifFalse: 			[ hTagList do: [:parentTag | hTagList do: [:childTag |					connected_hashtag add: (parentTag) asUppercase -> (childTag) asUppercase; yourself.].].].].			View := ROView new.	view := ROMondrianViewBuilder view: View.		view shape circle  		size: 30;		color: (Color blue alpha: 0.5).	view interaction on: ROMouseEnter do: [ :evt | 	view raw elementsAsEdge do: [ :edg | (edg from == evt element) ifTrue: [ ROBlink on: edg ] ].].		 	view nodes: (AllHashtag).	view shape line.	view 		edges: (connected_hashtag)		from: #key		to: #value.	view circleLayout.	ROEaselMorphic new populateMenuOn: view.	view open.	! !Object subclass: #RTOSMTweet	instanceVariableNames: 'locationCountMapping'	classVariableNames: ''	poolDictionaries: ''	category: 'StatisticsVisualization'!!RTOSMTweet methodsFor: 'as yet unclassified' stamp: 'AdityaBivalkar 10/31/2015 15:31'!locationCountMapping^ locationCountMapping.! !!RTOSMTweet methodsFor: 'as yet unclassified' stamp: 'KedarPitke 11/21/2015 17:29'!plotOnOpenStreetMap:locationDict on:composerView| v map e   timezones i size timezone location   count lat  lon place|	v := composerView.	map := RTOSM new.	e := map element.	v add: e.	timezones:=locationCountMapping keys.	i:=1.	size:=locationCountMapping size. 	[ i<=size ]whileTrue:[	timezone:=timezones at: i.	count:=locationCountMapping at: timezone.	location:=locationDict at: timezone.	lat:= location latitude asNumber.	lon:=location longitude asNumber.	 e:=(RTEllipse new		 size: (count*100);		 color: (Color blue alpha: 0.3)) 		elementOn:{(timezone).			  (count)}.		e @ RTPopup @ RTHighlightable.	   place:=lat @ lon.	   e translateTo: (map latLonToRoassal: place).	   v add: e.	i:=i+1.].   v canvas camera scale: 0.02; noInitializationWhenOpen.    v @ RTDraggableView.    v @ RTZoomableView. ! !!RTOSMTweet methodsFor: 'as yet unclassified' stamp: 'AdityaBivalkar 11/21/2015 12:20'!showTweetDistribution|reader locationDict locationToCountMapping keys size i locString tweetParser tweetArray user timezone count  tweet|reader:=CSVReader new.locationDict:=reader parseCSV.locationToCountMapping:=Dictionary new.keys:= locationDict keys.size:=keys size.i:=1.[ i<=size ]whileTrue:[locString:=keys at: i.locationToCountMapping at: locString put: 0.i:=i+1.	].locationToCountMapping.tweetParser:=TweetsParsor new.tweetArray:=tweetParser parseToJSON.size:= tweetArray size.i:=1.[ i<=size ]whileTrue:[tweet:=tweetArray at: i.user:= tweet user.timezone:=nil.timezone:=user time_zone.(timezone=nil)ifFalse:[count:=nil.count:=locationToCountMapping at: timezone ifPresent:[locationToCountMapping at: timezone.].(count= nil)ifFalse:[count:=count+1.locationToCountMapping at: timezone put:count.].	].i:=i+1.]. locationToCountMapping.locationCountMapping:=locationToCountMapping.^ (self plotOnOpenStreetMap:locationDict).! !!RTOSMTweet methodsFor: 'as yet unclassified' stamp: 'KedarPitke 11/21/2015 20:03'!plotSentimentOnOSM:sentimentsDict on:composerView| v map e   timezones i size timezone  lat  lon place sentiment netSentiment colorVal|	v := composerView.	map := RTOSM new.	e := map element.	v add: e.	timezones:=sentimentsDict keys.	i:=1.	size:=sentimentsDict size. 	[ i<=size ]whileTrue:[	timezone:=timezones at: i.	sentiment:=sentimentsDict at: timezone.	lat:= sentiment latitude asNumber.	lon:=sentiment longitude asNumber.	netSentiment:=sentiment netSentiment.	colorVal:=(Color green alpha: 0.9).     ( netSentiment < 0 )ifTrue:[colorVal:=(Color red alpha: 0.3). 	netSentiment:=(netSentiment*(-1))].	e:=(RTEllipse new		 size: (netSentiment*50);		 color: colorVal) 		elementOn:{(timezone).			  (netSentiment)}.		e @ RTPopup @ RTHighlightable.	   place:=lat @ lon.	   e translateTo: (map latLonToRoassal: place).	   v add: e.	i:=i+1.].   v canvas camera scale: 0.02; noInitializationWhenOpen.    v @ RTDraggableView.    v @ RTZoomableView.   	! !!RTOSMTweet methodsFor: 'as yet unclassified' stamp: 'AdityaBivalkar 11/21/2015 13:05'!plotOnOpenStreetMap:locationDict| v map e   timezones i size timezone location   count lat  lon place|	v := RTView new.	map := RTOSM new.	e := map element.	v add: e.	timezones:=locationCountMapping keys.	i:=1.	size:=locationCountMapping size. 	[ i<=size ]whileTrue:[	timezone:=timezones at: i.	count:=locationCountMapping at: timezone.	location:=locationDict at: timezone.	lat:= location latitude asNumber.	lon:=location longitude asNumber.	 e:=(RTEllipse new		 size: (count*200)%100000;		 color: (Color blue alpha: 0.3)) 		elementOn:{(timezone).			  (count)}.		e @ RTPopup @ RTHighlightable.	   place:=lat @ lon.	   e translateTo: (map latLonToRoassal: place).	   v add: e.	i:=i+1.].   v canvas camera scale: 0.02; noInitializationWhenOpen.    v @ RTDraggableView.    v @ RTZoomableView.	^v.    	! !!RTOSMTweet methodsFor: 'as yet unclassified' stamp: 'AdityaBivalkar 11/15/2015 19:54'!plotSentimentOnOSM:sentimentsDict| v map e   timezones i size timezone  lat  lon place sentiment netSentiment colorVal|	v := RTView new.	map := RTOSM new.	e := map element.	v add: e.	timezones:=sentimentsDict keys.	i:=1.	size:=sentimentsDict size. 	[ i<=size ]whileTrue:[	timezone:=timezones at: i.	sentiment:=sentimentsDict at: timezone.	lat:= sentiment latitude asNumber.	lon:=sentiment longitude asNumber.	netSentiment:=sentiment netSentiment.	colorVal:=(Color green alpha: 0.9).     ( netSentiment < 0 )ifTrue:[colorVal:=(Color red alpha: 0.3). 	netSentiment:=(netSentiment*(-1))].	e:=(RTEllipse new		 size: (netSentiment*50);		 color: colorVal) 		elementOn:{(timezone).			  (netSentiment)}.		e @ RTPopup @ RTHighlightable.	   place:=lat @ lon.	   e translateTo: (map latLonToRoassal: place).	   v add: e.	i:=i+1.].   v canvas camera scale: 0.02; noInitializationWhenOpen.    v @ RTDraggableView.    v @ RTZoomableView.	^v.    	! !!RTOSMTweet methodsFor: 'as yet unclassified' stamp: 'AdityaBivalkar 10/31/2015 15:31'!locationCountMapping:mappinglocationCountMapping:=mapping.! !TestCase subclass: #TestTotalTweets	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'StatisticsVisualization'!!TestTotalTweets methodsFor: 'as yet unclassified' stamp: 'MeenalKulkarni 11/22/2015 16:53'!testInitDayOfWeekData	| this a dataSet size d1 d2 d3 d4 d5 d6 d7 |		this := self.	a := TotalTweets  new.	dataSet := a initDayOfWeekData.	size := dataSet size.	this assert: (size = 7).		dataSet do: [ :el | this assert: ( el size = 4)  ].	dataSet do: [ :el | this assert: ( el includes: 0)  ].	d1 := dataSet at: 1.	this assert: (d1 includes: 'Mon').		d2 := dataSet at: 2.	this assert: (d2 includes: 'Tue').		d3 := dataSet at: 3.	this assert: (d3 includes: 'Wed').		d4 := dataSet at: 4.	this assert: (d4 includes: 'Thu').		d5 := dataSet at: 5.	this assert: (d5 includes: 'Fri').		d6 := dataSet at: 6.	this assert: (d6 includes: 'Sat').		d7 := dataSet at: 7.	this assert: (d7 includes: 'Sun').! !!TestTotalTweets methodsFor: 'as yet unclassified' stamp: 'MeenalKulkarni 11/22/2015 16:53'!testInitMonthlyData	| this a dataSet size             d1 d2 d3 d4 d5 d6 d7 d8 d9 d10 d11 d12 |		this := self.	a := TotalTweets  new.	dataSet := a initMonthlyData .	size := dataSet size.	this assert: (size = 12).		dataSet do: [ :el | this assert: ( el size = 4)  ].	dataSet do: [ :el | this assert: ( el includes: 0)  ].		d1 := dataSet at: 1.	this assert: (d1 includes: 'Jan').		d2 := dataSet at: 2.	this assert: (d2 includes: 'Feb').		d3 := dataSet at: 3.	this assert: (d3 includes: 'Mar').		d4 := dataSet at: 4.	this assert: (d4 includes: 'Apr').		d5 := dataSet at: 5.	this assert: (d5 includes: 'May').		d6 := dataSet at: 6.	this assert: (d6 includes: 'Jun').		d7 := dataSet at: 7.	this assert: (d7 includes: 'Jul').		d8 := dataSet at: 8.	this assert: (d8 includes: 'Aug').		d9 := dataSet at: 9.	this assert: (d9 includes: 'Sep').		d10 := dataSet at: 10.	this assert: (d10 includes: 'Oct').		d11 := dataSet at: 11.	this assert: (d11 includes: 'Nov').		d12 := dataSet at: 12.	this assert: (d12 includes: 'Dec').	! !